
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user has a specific role
    function hasRole(role) {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }

    // Helper function to check if a user is a managed student of the requester
    function isManagedStudent(studentId) {
      return request.auth.uid in get(/databases/$(database)/documents/users/$(studentId)).data.associatedParentIds;
    }

    // User profiles:
    // - Authenticated users can read any profile (for names, avatars etc.)
    // - Users can only create/update their own profile
    // - Deletion might be restricted (e.g., admin only or self with conditions)
    match /users/{userId} {
      allow read: if request.auth.uid != null;
      allow create: if request.auth.uid != null && request.auth.uid == userId;
      allow update: if request.auth.uid != null && request.auth.uid == userId;
      allow delete: if request.auth.uid != null && request.auth.uid == userId; // Or more restrictive
    }

    // Groups:
    // - Authenticated users can read group details.
    // - Only authenticated users can create groups (creator becomes admin).
    // - Only group admins can update group details (name, description, image).
    // - For adding/removing members, specific logic in `memberIds` and `adminIds` updates handled by backend/transactions usually,
    //   but rules here ensure only admins can initiate changes to core group doc fields.
    match /groups/{groupId} {
      allow read: if request.auth.uid != null;
      allow create: if request.auth.uid != null
                    && request.auth.uid == request.resource.data.createdBy
                    && request.resource.data.name is string && request.resource.data.name != ''
                    && request.resource.data.description is string && request.resource.data.description != ''
                    && request.resource.data.memberIds is list && request.resource.data.memberIds.size() == 1 && request.resource.data.memberIds[0] == request.auth.uid
                    && request.resource.data.adminIds is list && request.resource.data.adminIds.size() == 1 && request.resource.data.adminIds[0] == request.auth.uid
                    && (request.resource.data.imageUrl == null || request.resource.data.imageUrl is string)
                    && (request.resource.data.dataAiHint == null || request.resource.data.dataAiHint is string)
                    && (request.resource.data.createdAt == request.time || (request.resource.data.createdAt is map && request.resource.data.createdAt.get('.sv') == 'timestamp'));


      allow update: if request.auth.uid != null && request.auth.uid in resource.data.adminIds // Only admins
                    // Allow updates only to specific fields, not adminIds/memberIds directly here (managed by actions)
                    && request.resource.data.containsKey('name') && request.resource.data.name is string && request.resource.data.name != ''
                    && request.resource.data.containsKey('description') && request.resource.data.description is string
                    && (!request.resource.data.containsKey('imageUrl') || request.resource.data.imageUrl is string)
                    && (!request.resource.data.containsKey('dataAiHint') || request.resource.data.dataAiHint is string)
                    // Prevent changing createdBy, createdAt, memberIds, adminIds through this general update rule
                    && request.resource.data.createdBy == resource.data.createdBy
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.memberIds == resource.data.memberIds
                    && request.resource.data.adminIds == resource.data.adminIds;

      // allow delete: if request.auth.uid != null && request.auth.uid in resource.data.adminIds; // Or only creator
    }

    // Events:
    // - Authenticated users can read events.
    // - Authenticated users can create events (creator UID is stored).
    // - Only the event creator or an admin can update/delete an event.
    match /events/{eventId} {
      allow read: if request.auth.uid != null;
      allow create: if request.auth.uid != null
                    && request.auth.uid == request.resource.data.createdBy
                    && request.resource.data.name is string && request.resource.data.name != ''
                    && request.resource.data.eventTimestamp is timestamp
                    && request.resource.data.location is string && request.resource.data.location != ''
                    && request.resource.data.eventType is string && request.resource.data.eventType != ''
                    && request.resource.data.associatedGroupIds is list
                    && (request.resource.data.createdAt == request.time || (request.resource.data.createdAt is map && request.resource.data.createdAt.get('.sv') == 'timestamp'));

      allow update: if request.auth.uid != null && request.auth.uid == resource.data.createdBy; // Or admin
      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.createdBy; // Or admin
    }

    // Rydz (Carpool Requests/Rides):
    // - Authenticated users can read rydz (e.g., if they are a passenger or driver, further checks might be needed).
    // - Authenticated users can create rydz requests for themselves or their managed students.
    // - Updates and deletes might be restricted to involved parties or admins.
    match /rydz/{rydId} {
      allow read: if request.auth.uid != null; // Can be further restricted
      allow create: if request.auth.uid != null
                    && request.auth.uid == request.resource.data.requestedBy
                    && request.resource.data.destination is string && request.resource.data.destination != ''
                    && request.resource.data.pickupLocation is string && request.resource.data.pickupLocation != ''
                    && request.resource.data.rydTimestamp is timestamp
                    && request.resource.data.earliestPickupTimestamp is timestamp
                    && request.resource.data.status is string // e.g., "requested", "confirmed"
                    && request.resource.data.passengerIds is list && request.resource.data.passengerIds.size() > 0
                    // Corrected check for serverTimestamp:
                    && (request.resource.data.createdAt is map && request.resource.data.createdAt.get(".sv") == "timestamp")
                    && (request.resource.data.eventId == null || request.resource.data.eventId is string)
                    && (request.resource.data.eventName == null || request.resource.data.eventName is string)
                    && (request.resource.data.notes == null || request.resource.data.notes is string)
                    && (request.resource.data.driverId == null || request.resource.data.driverId is string)
                    && (request.resource.data.updatedAt == null || request.resource.data.updatedAt is timestamp || (request.resource.data.updatedAt is map && request.resource.data.updatedAt.get(".sv") == "timestamp"));


      // Add update and delete rules as needed, e.g.:
      // allow update: if request.auth.uid != null && (request.auth.uid == resource.data.requestedBy || request.auth.uid == resource.data.driverId);
      // allow delete: if request.auth.uid != null && request.auth.uid == resource.data.requestedBy;
    }

    // eventDriverStates
    match /eventDriverStates/{stateId} {
      allow read: if request.auth.uid != null;
      // Users can only create/update their own driver state for an event.
      // stateId should be composite `${eventId}_${driverId}`
      allow create, update: if request.auth.uid != null
                              && request.auth.uid == request.resource.data.driverId
                              && request.resource.data.eventId is string
                              && request.resource.data.status is string
                              && (request.resource.data.seatsAvailable == null || request.resource.data.seatsAvailable is number)
                              && (request.resource.data.updatedAt is map && request.resource.data.updatedAt.get(".sv") == "timestamp");
      // No general delete, perhaps mark as 'not_attending' or similar
    }

    // Other collections as needed...
  }
}

    