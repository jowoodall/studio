
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null && request.auth.uid != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function userRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    function isDriver(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId)).data;
      return userDoc.canDrive == true;
    }

    function isAdmin() {
      return isAuthenticated() && userRole() == 'admin';
    }

    function isParent() {
      return isAuthenticated() && userRole() == 'parent';
    }
    
    function isStudent() {
      return isAuthenticated() && userRole() == 'student';
    }

    // Users Collection
    match /users/{userId} {
      allow read: if isAuthenticated(); // Any authenticated user can read any user profile for now.
                                        // Consider if this should be more restrictive (e.g., only self or admins).
      allow create: if request.auth.uid == userId && 
                      request.resource.data.uid == userId &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.fullName is string && request.resource.data.fullName.size() > 0 &&
                      request.resource.data.role in ['student', 'parent'] && // Initially, users can only sign up as student or parent
                      !exists(/databases/$(database)/documents/users/$(userId)); // Prevent overwriting existing profiles through create
                      
      allow update: if isUser(userId) || isAdmin(); // User can update their own profile, or an admin can.
                                                  // Add specific field validations for updates if needed.
                                                  // Disallow role changes by non-admins:
                                                  // e.g. !(request.resource.data.role != resource.data.role && !isAdmin())
      allow delete: if isAdmin(); // Only admins can delete user profiles.
    }

    // Groups Collection
    match /groups/{groupId} {
      allow read: if isAuthenticated(); // Any authenticated user can view group details.
      allow create: if isAuthenticated() && 
                      request.resource.data.createdBy == request.auth.uid &&
                      request.auth.uid in request.resource.data.memberIds &&
                      request.auth.uid in request.resource.data.adminIds &&
                      request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                      request.resource.data.description is string;
                      
      allow update: if isAuthenticated() && 
                      (request.auth.uid in resource.data.adminIds || isAdmin()) &&
                      // Prevent changing createdBy, createdAt
                      request.resource.data.createdBy == resource.data.createdBy &&
                      request.resource.data.createdAt == resource.data.createdAt; 
                      // Admins can add/remove members/admins.
                      // Ensure memberIds and adminIds are lists of strings (UIDs).

      allow delete: if isAuthenticated() && (request.auth.uid == resource.data.createdBy || isAdmin()); // Creator or admin can delete.
    }

    // Events Collection
    match /events/{eventId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.createdBy == request.auth.uid;
                      // Validate event data: name, eventTimestamp, location, eventType must exist
                      // request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                      // request.resource.data.eventTimestamp is timestamp &&
                      // request.resource.data.location is string && request.resource.data.location.size() > 0 &&
                      // request.resource.data.eventType is string && request.resource.data.eventType.size() > 0;
      allow update: if isAuthenticated() && (request.auth.uid == resource.data.createdBy || isAdmin());
                      // Prevent changing createdBy, createdAt
                      // request.resource.data.createdBy == resource.data.createdBy &&
                      // request.resource.data.createdAt == resource.data.createdAt;
      allow delete: if isAuthenticated() && (request.auth.uid == resource.data.createdBy || isAdmin());
    }

    // Rydz Collection (Ryd Requests)
    match /rydz/{rydId} {
      allow read: if isAuthenticated(); // Or more specific: if request.auth.uid == resource.data.requestedBy || (resource.data.driverId != null && request.auth.uid == resource.data.driverId) || isAdmin()
      allow create: if isAuthenticated() && 
                      request.resource.data.requestedBy == request.auth.uid &&
                      request.resource.data.passengerIds[0] == request.auth.uid || // If student requests for self
                      (isParent() && request.resource.data.requestedBy == request.auth.uid && request.resource.data.passengerIds.size() > 0) && // If parent requests for student(s)
                      request.resource.data.status == 'requested' &&
                      request.resource.data.destination is string && request.resource.data.destination.size() > 0 &&
                      request.resource.data.pickupLocation is string && request.resource.data.pickupLocation.size() > 0 &&
                      request.resource.data.rydTimestamp is timestamp &&
                      request.resource.data.earliestPickupTimestamp is timestamp;

      allow update: if isAuthenticated() && 
                      (request.auth.uid == resource.data.requestedBy || // Requester can update (e.g., cancel)
                       (resource.data.driverId != null && request.auth.uid == resource.data.driverId) || // Assigned driver can update
                       isAdmin()); // Admin can update
                      // Specific field update logic (e.g. status changes) can be more granular.
                      // Ensure requestedBy, createdAt cannot be changed.
                      // request.resource.data.requestedBy == resource.data.requestedBy &&
                      // request.resource.data.createdAt == resource.data.createdAt;
                      
      allow delete: if isAuthenticated() && (request.auth.uid == resource.data.requestedBy || isAdmin()); // Requester or admin can delete
    }
    
    // ActiveRydz Collection (Offered/In-Progress Rydz)
    match /activeRydz/{activeRydId} {
      // Who can read an active ryd? Driver, passengers, admins.
      allow read: if isAuthenticated() &&
                      (request.auth.uid == resource.data.driverId ||
                       request.auth.uid in resource.data.passengerManifest.map(p => p.userId) || // This requires passengerManifest to be populated
                       isAdmin());
                       
      allow create: if isAuthenticated() &&
                      isDriver(request.resource.data.driverId) && // The creator must be a registered driver
                      request.auth.uid == request.resource.data.driverId && // The authenticated user must be the driver
                      request.resource.data.status == 'planning' && // Ryd must start in 'planning' status
                      request.resource.data.passengerManifest == [] && // Passenger manifest must be empty on creation
                      request.resource.data.startLocationAddress is string && request.resource.data.startLocationAddress.size() > 0 &&
                      request.resource.data.finalDestinationAddress is string && request.resource.data.finalDestinationAddress.size() > 0 &&
                      request.resource.data.vehicleDetails.passengerCapacity is string && 
                      request.resource.data.vehicleDetails.passengerCapacity.matches("^[1-8]$") && // Ensure capacity is "1" through "8"
                      // Ensure associatedEventId points to a real event if provided
                      (request.resource.data.associatedEventId == null || exists(/databases/$(database)/documents/events/$(request.resource.data.associatedEventId))) &&
                      // Ensure event has a location if associatedEventId is provided
                      (request.resource.data.associatedEventId == null || get(/databases/$(database)/documents/events/$(request.resource.data.associatedEventId)).data.location.size() > 0);

      allow update: if isAuthenticated() &&
                      (request.auth.uid == resource.data.driverId || // Driver can update
                       isAdmin()); // Admin can update
                      // More granular checks for specific fields are recommended.
                      // e.g., only driver can change status from 'planning' to 'awaiting_passengers'
                      // Ensure driverId, createdAt cannot be changed.
                      // request.resource.data.driverId == resource.data.driverId &&
                      // request.resource.data.createdAt == resource.data.createdAt;
                      
      allow delete: if isAuthenticated() &&
                      (request.auth.uid == resource.data.driverId || // Driver can delete (e.g., if in planning)
                       isAdmin()); // Admin can delete
    }

    // EventDriverStates Collection
    match /eventDriverStates/{stateId} {
      allow read: if isAuthenticated(); // Any authenticated user can see driver statuses for an event.
      allow create: if isAuthenticated() && 
                      request.resource.data.driverId == request.auth.uid && // User creating their own status
                      request.resource.data.eventId is string && request.resource.data.eventId.size() > 0 &&
                      request.resource.data.status in ['driving', 'not_driving', 'pending_response', 'full_car'] &&
                      // If 'driving' or 'full_car', seatsAvailable must be provided (or handled by client to be 0 for full_car)
                      ((request.resource.data.status == 'driving' || request.resource.data.status == 'full_car') ? request.resource.data.seatsAvailable is number : true);

      allow update: if isAuthenticated() && request.auth.uid == resource.data.driverId; // Only the driver can update their own status.
                      // request.resource.data.driverId == resource.data.driverId && // driverId cannot change
                      // request.resource.data.eventId == resource.data.eventId && // eventId cannot change
                      // request.resource.data.status in ['driving', 'not_driving', 'pending_response', 'full_car'] &&
                      // ((request.resource.data.status == 'driving' || request.resource.data.status == 'full_car') ? request.resource.data.seatsAvailable is number : true);
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.driverId; // Driver can remove their status.
    }
  }
}

    