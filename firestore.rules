
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Rules for user profiles
    match /users/{userId} {
      allow read: if request.auth.uid != null;
      allow create: if request.auth.uid != null && request.auth.uid == userId;
      allow update: if request.auth.uid != null && request.auth.uid == userId;
      allow delete: if false;
    }

    // Rules for groups
    match /groups/{groupId} {
      allow read: if request.auth.uid != null;
      allow create: if request.auth.uid != null
                    && request.auth.uid == request.resource.data.createdBy
                    && request.resource.data.name is string && request.resource.data.name.size() > 0
                    && request.resource.data.description is string
                    && request.resource.data.memberIds is list && request.resource.data.memberIds.size() > 0 && request.auth.uid in request.resource.data.memberIds
                    && request.resource.data.adminIds is list && request.resource.data.adminIds.size() > 0 && request.auth.uid in request.resource.data.adminIds;
      allow update: if request.auth.uid != null && request.auth.uid in resource.data.adminIds;
      allow delete: if request.auth.uid != null && request.auth.uid in resource.data.adminIds;
    }

    // Rules for events
    match /events/{eventId} {
      allow read: if request.auth.uid != null;
      allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.createdBy;
      allow update: if request.auth.uid != null && request.auth.uid == resource.data.createdBy;
      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.createdBy;
    }

    // Rules for event driver states
    match /eventDriverStates/{stateId} {
        allow read: if request.auth.uid != null;
        allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.driverId;
        allow update: if request.auth.uid != null && request.auth.uid == resource.data.driverId;
        allow delete: if false;
    }

    // Rules for rydz (requests)
    match /rydz/{rydId} {
      allow read: if request.auth.uid != null;

      allow create: if request.auth.uid != null
        && request.auth.uid == request.resource.data.requestedBy
        && request.resource.data.destination is string && request.resource.data.destination.size() > 0
        && request.resource.data.pickupLocation is string && request.resource.data.pickupLocation.size() > 0
        && request.resource.data.rydTimestamp is timestamp
        && request.resource.data.earliestPickupTimestamp is timestamp
        && request.resource.data.status is string && request.resource.data.status == "requested"
        && request.resource.data.passengerIds is list && request.resource.data.passengerIds.size() > 0
        && (request.resource.data.notes == null || request.resource.data.notes is string)
        && request.resource.data.createdAt == request.time
        && (request.resource.data.eventId == null || request.resource.data.eventId is string)
        && (request.resource.data.eventName == null || request.resource.data.eventName is string)
        && request.resource.data.keys().hasAll(['requestedBy', 'destination', 'pickupLocation', 'rydTimestamp', 'earliestPickupTimestamp', 'status', 'passengerIds', 'createdAt'])
        && request.resource.data.keys().size() >= 8 && request.resource.data.keys().size() <= 11;

      allow update: if request.auth.uid != null && request.auth.uid == resource.data.requestedBy
                      // Allow updates only to specific fields by checking affectedKeys
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notes', 'status', 'updatedAt', 'assignedActiveRydId'])
                      // Ensure server timestamp for updatedAt
                      && request.resource.data.updatedAt == request.time;
                      // Add specific status transition validation if needed here

      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.requestedBy
                      && resource.data.status == 'requested';
    }

    // Rules for activeRydz
    match /activeRydz/{activeRydId} {
      allow create: if request.auth.uid != null
                      && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.canDrive == true
                      && request.resource.data.driverId == request.auth.uid
                      && request.resource.data.associatedEventId is string
                      && request.resource.data.status is string // e.g., 'planning', 'available_for_passengers'
                      && request.resource.data.vehicleDetails is map
                      && request.resource.data.vehicleDetails.passengerCapacity is string
                      && request.resource.data.passengerManifest is list && request.resource.data.passengerManifest.size() == 0 // Empty initially
                      && request.resource.data.createdAt == request.time
                      && request.resource.data.actualDepartureTime is timestamp
                      && (request.resource.data.startLocationAddress is string || request.resource.data.startLocationAddress == null)
                      && (request.resource.data.finalDestinationAddress is string || request.resource.data.finalDestinationAddress == null)
                      && (request.resource.data.notes is string || request.resource.data.notes == null)
                      && (request.resource.data.vehicleDetails.make is string || request.resource.data.vehicleDetails.make == null)
                      && (request.resource.data.vehicleDetails.model is string || request.resource.data.vehicleDetails.model == null)
                      && request.resource.data.keys().hasAll(['driverId', 'associatedEventId', 'status', 'vehicleDetails', 'passengerManifest', 'createdAt', 'actualDepartureTime'])
                      && request.resource.data.keys().size() >= 7 && request.resource.data.keys().size() <= 11;

      allow read: if request.auth.uid != null
                    && (request.auth.uid == resource.data.driverId ||
                        (resource.data.passengerManifest is list && resource.data.passengerManifest.exists(p, p.userId == request.auth.uid))
                       ); // Driver or a passenger in the manifest

      allow update: if request.auth.uid != null && request.auth.uid == resource.data.driverId // Only driver can update
                      // Ensure immutable fields are not being changed
                      && request.resource.data.get('driverId', resource.data.driverId) == resource.data.driverId
                      && request.resource.data.get('associatedEventId', resource.data.associatedEventId) == resource.data.associatedEventId
                      && request.resource.data.get('createdAt', resource.data.createdAt) == resource.data.createdAt
                      // Check that only allowed top-level fields are being modified
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                           'status', 'updatedAt', 'vehicleDetails', 'actualDepartureTime',
                           'estimatedCompletionTime', 'startLocationAddress',
                           'finalDestinationAddress', 'routePolyline', 'passengerManifest', 'notes'
                         ])
                      // If passengerManifest is updated, validate its new structure
                      && (
                           !request.resource.data.diff(resource.data).affectedKeys().hasAny(['passengerManifest']) || // If manifest is not affected, skip validation
                           (
                             request.resource.data.passengerManifest is list &&
                             request.resource.data.passengerManifest.all(item,
                               item.userId is string && item.userId.size() > 0 &&
                               item.originalRydRequestId is string && item.originalRydRequestId.size() > 0 &&
                               item.pickupAddress is string && item.pickupAddress.size() > 0 &&
                               item.destinationAddress is string && item.destinationAddress.size() > 0 &&
                               item.status is string && (
                                 item.status == 'awaiting_pickup' || item.status == 'on_board' ||
                                 item.status == 'dropped_off' || item.status == 'missed_pickup' ||
                                 item.status == 'cancelled_by_passenger'
                               ) &&
                               item.keys().hasOnly([
                                 'userId', 'originalRydRequestId', 'pickupAddress', 'destinationAddress', 'status',
                                 'pickupOrder', 'dropoffOrder', 'estimatedPickupTime', 'actualPickupTime',
                                 'estimatedDropoffTime', 'actualDropoffTime', 'notes'
                               ]) && // Check optional field types if they exist
                                (item.get('notes', null) == null || item.get('notes', '') is string) &&
                                (item.get('pickupOrder', null) == null || item.get('pickupOrder', 0) is number) &&
                                (item.get('dropoffOrder', null) == null || item.get('dropoffOrder', 0) is number) &&
                                (item.get('estimatedPickupTime', null) == null || item.get('estimatedPickupTime', request.time) is timestamp) &&
                                (item.get('actualPickupTime', null) == null || item.get('actualPickupTime', request.time) is timestamp) &&
                                (item.get('estimatedDropoffTime', null) == null || item.get('estimatedDropoffTime', request.time) is timestamp) &&
                                (item.get('actualDropoffTime', null) == null || item.get('actualDropoffTime', request.time) is timestamp)
                             )
                           )
                         )
                      // Validate top-level status field (add specific valid statuses if needed)
                      && request.resource.data.status is string
                      // Enforce server timestamp for updatedAt
                      && request.resource.data.updatedAt == request.time;

      allow delete: if false;
    }
  }
}

    