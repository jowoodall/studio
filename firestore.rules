
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Rules for user profiles
    match /users/{userId} {
      // Allow users to read their own profile and other basic profiles if authenticated
      allow read: if request.auth.uid != null;
      // Allow users to create their own profile (e.g., on signup)
      allow create: if request.auth.uid != null && request.auth.uid == userId;
      // Allow users to update their own profile
      allow update: if request.auth.uid != null && request.auth.uid == userId;
      // Generally, disallow direct deletion of user profiles from client
      allow delete: if false;
    }

    // Rules for groups
    match /groups/{groupId} {
      allow read: if request.auth.uid != null; // Any authenticated user can read group details
      allow create: if request.auth.uid != null 
                    && request.auth.uid == request.resource.data.createdBy
                    && request.resource.data.name is string && request.resource.data.name.size() > 0
                    && request.resource.data.description is string
                    && request.resource.data.memberIds is list && request.resource.data.memberIds.size() > 0 && request.auth.uid in request.resource.data.memberIds
                    && request.resource.data.adminIds is list && request.resource.data.adminIds.size() > 0 && request.auth.uid in request.resource.data.adminIds;
      allow update: if request.auth.uid != null && request.auth.uid in resource.data.adminIds; // Only group admins can update
      allow delete: if request.auth.uid != null && request.auth.uid in resource.data.adminIds; // Only group admins can delete
    }

    // Rules for events
    match /events/{eventId} {
      allow read: if request.auth.uid != null; // Any authenticated user can read event details
      allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.createdBy;
      allow update: if request.auth.uid != null && request.auth.uid == resource.data.createdBy; // Only event creator can update
      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.createdBy; // Only event creator can delete
    }

    // Rules for event driver states
    match /eventDriverStates/{stateId} {
        allow read: if request.auth.uid != null;
        allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.driverId;
        allow update: if request.auth.uid != null && request.auth.uid == resource.data.driverId;
        allow delete: if false; // Or based on specific conditions like event creator
    }

    // Rules for rydz (requests)
    match /rydz/{rydId} {
      allow read: if request.auth.uid != null; 
      
      allow create: if request.auth.uid != null
        && request.auth.uid == request.resource.data.requestedBy
        && request.resource.data.destination is string && request.resource.data.destination.size() > 0
        && request.resource.data.pickupLocation is string && request.resource.data.pickupLocation.size() > 0
        && request.resource.data.rydTimestamp is timestamp
        && request.resource.data.earliestPickupTimestamp is timestamp
        && request.resource.data.status is string && request.resource.data.status == "requested"
        && request.resource.data.passengerIds is list && request.resource.data.passengerIds.size() > 0
        && (request.resource.data.notes == null || request.resource.data.notes is string)
        && request.resource.data.createdAt == request.time 
        && (request.resource.data.eventId == null || request.resource.data.eventId is string)
        && (request.resource.data.eventName == null || request.resource.data.eventName is string)
        && request.resource.data.keys().hasAll(['requestedBy', 'destination', 'pickupLocation', 'rydTimestamp', 'earliestPickupTimestamp', 'status', 'passengerIds', 'createdAt'])
        && request.resource.data.keys().size() >= 8 && request.resource.data.keys().size() <= 11;

      allow update: if request.auth.uid != null && request.auth.uid == resource.data.requestedBy &&
                      // Allow updating only specific fields
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'notes', 'assignedActiveRydId', 'updatedAt']) &&
                      // Prevent changing critical immutable fields
                      request.resource.data.requestedBy == resource.data.requestedBy &&
                      request.resource.data.destination == resource.data.destination &&
                      request.resource.data.pickupLocation == resource.data.pickupLocation &&
                      request.resource.data.rydTimestamp == resource.data.rydTimestamp &&
                      request.resource.data.createdAt == resource.data.createdAt;

      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.requestedBy && resource.data.status == 'requested';
    }

    // Rules for Active Rydz
    match /activeRydz/{activeRydId} {
      allow create: if request.auth != null &&
                       // Check canDrive status of the user *being set as the driver*
                       get(/databases/$(database)/documents/users/$(request.resource.data.driverId)).data.canDrive == true &&
                       // Ensure the authenticated user is the one being set as the driver
                       request.auth.uid == request.resource.data.driverId &&
                       // Validate required fields and their types
                       request.resource.data.driverId is string && request.resource.data.driverId.size() > 0 &&
                       request.resource.data.associatedEventId is string && request.resource.data.associatedEventId.size() > 0 &&
                       request.resource.data.status is string && (request.resource.data.status == "planning" || request.resource.data.status == "available_for_passengers") && // Adjust initial statuses as needed
                       request.resource.data.vehicleDetails is map &&
                       request.resource.data.vehicleDetails.passengerCapacity is string && // or number depending on your type
                       request.resource.data.passengerManifest is list && request.resource.data.passengerManifest.size() == 0 && // Initially empty
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time &&
                       request.resource.data.actualDepartureTime is timestamp &&
                       request.resource.data.startLocationAddress is string && request.resource.data.startLocationAddress.size() > 0 &&
                       request.resource.data.finalDestinationAddress is string && request.resource.data.finalDestinationAddress.size() > 0 &&
                       (request.resource.data.notes is string || request.resource.data.notes == null) &&
                       // Ensure no unexpected fields are being sent
                       request.resource.data.keys().hasAll(['driverId', 'associatedEventId', 'status', 'vehicleDetails', 'passengerManifest', 'createdAt', 'updatedAt', 'actualDepartureTime', 'startLocationAddress', 'finalDestinationAddress', 'notes']) &&
                       request.resource.data.keys().size() == 11; // Adjust count based on final fields

      allow read: if request.auth.uid != null;
                      // Previous detailed rule was:
                      // (request.auth.uid == resource.data.driverId ||
                      //  resource.data.passengerManifest.exists(p, p.userId == request.auth.uid));
                      // Simplified for event listing, refine if needed for direct access security.

      allow update: if request.auth.uid != null && request.auth.uid == resource.data.driverId &&
                       // Prevent changing immutable fields
                       request.resource.data.driverId == resource.data.driverId &&
                       request.resource.data.associatedEventId == resource.data.associatedEventId &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       // Validate specific fields on update, e.g., status progression, manifest changes
                       (request.resource.data.status is string) &&
                       (request.resource.data.passengerManifest is list) &&
                       request.resource.data.passengerManifest.all(item,
                         item.userId is string && item.userId.size() > 0 &&
                         item.originalRydRequestId is string && item.originalRydRequestId.size() > 0 &&
                         item.pickupAddress is string && item.pickupAddress.size() > 0 &&
                         item.destinationAddress is string && item.destinationAddress.size() > 0 &&
                         item.status is string &&
                         (item.pickupOrder == null || item.pickupOrder is number) &&
                         (item.dropoffOrder == null || item.dropoffOrder is number) &&
                         (item.estimatedPickupTime == null || item.estimatedPickupTime is timestamp) &&
                         (item.actualPickupTime == null || item.actualPickupTime is timestamp) &&
                         (item.estimatedDropoffTime == null || item.estimatedDropoffTime is timestamp) &&
                         (item.actualDropoffTime == null || item.actualDropoffTime is timestamp) &&
                         (item.notes == null || item.notes is string) &&
                         item.keys().hasAll(['userId', 'originalRydRequestId', 'pickupAddress', 'destinationAddress', 'status']) && // Check required keys
                         item.keys().size() >= 5 && item.keys().size() <= 11 // Min and max expected keys in a manifest item
                       ) &&
                       request.resource.data.updatedAt == request.time;
      allow delete: if false; // Deletion should likely be an admin/system action
    }
  }
}
