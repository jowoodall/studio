
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Rules for user profiles
    match /users/{userId} {
      // Allow users to read their own profile and other basic profiles if authenticated
      allow read: if request.auth.uid != null;
      // Allow users to create their own profile (e.g., on signup)
      allow create: if request.auth.uid != null && request.auth.uid == userId;
      // Allow users to update their own profile
      allow update: if request.auth.uid != null && request.auth.uid == userId;
      // Generally, disallow direct deletion of user profiles from client
      allow delete: if false;
    }

    // Rules for groups
    match /groups/{groupId} {
      allow read: if request.auth.uid != null; // Any authenticated user can read group details
      allow create: if request.auth.uid != null 
                    && request.auth.uid == request.resource.data.createdBy
                    && request.resource.data.name is string && request.resource.data.name.size() > 0
                    && request.resource.data.description is string
                    && request.resource.data.memberIds is list && request.resource.data.memberIds.size() > 0 && request.auth.uid in request.resource.data.memberIds
                    && request.resource.data.adminIds is list && request.resource.data.adminIds.size() > 0 && request.auth.uid in request.resource.data.adminIds;
      allow update: if request.auth.uid != null && request.auth.uid in resource.data.adminIds; // Only group admins can update
      allow delete: if request.auth.uid != null && request.auth.uid in resource.data.adminIds; // Only group admins can delete
    }

    // Rules for events
    match /events/{eventId} {
      allow read: if request.auth.uid != null; // Any authenticated user can read event details
      allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.createdBy;
      allow update: if request.auth.uid != null && request.auth.uid == resource.data.createdBy; // Only event creator can update
      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.createdBy; // Only event creator can delete
    }

    // Rules for event driver states
    match /eventDriverStates/{stateId} {
        allow read: if request.auth.uid != null;
        allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.driverId;
        allow update: if request.auth.uid != null && request.auth.uid == resource.data.driverId;
        allow delete: if false; // Or based on specific conditions like event creator
    }

    // Rules for rydz (requests)
    match /rydz/{rydId} {
      allow read: if request.auth.uid != null; 
      
      allow create: if request.auth.uid != null
        && request.auth.uid == request.resource.data.requestedBy
        && request.resource.data.destination is string && request.resource.data.destination.size() > 0
        && request.resource.data.pickupLocation is string && request.resource.data.pickupLocation.size() > 0
        && request.resource.data.rydTimestamp is timestamp
        && request.resource.data.earliestPickupTimestamp is timestamp
        && request.resource.data.status is string && request.resource.data.status == "requested"
        && request.resource.data.passengerIds is list && request.resource.data.passengerIds.size() > 0
        && (request.resource.data.notes == null || request.resource.data.notes is string) // notes is optional
        && (request.resource.data.eventId == null || request.resource.data.eventId is string) // eventId is optional
        && (request.resource.data.eventName == null || request.resource.data.eventName is string) // eventName is optional
        // Check for expected keys. `createdAt` is handled by serverTimestamp, so not in request.resource.data
        && request.resource.data.keys().hasAll(['requestedBy', 'destination', 'pickupLocation', 'rydTimestamp', 'earliestPickupTimestamp', 'status', 'passengerIds'])
        // Size check accounts for optional fields: eventId, eventName, notes. Base 7 keys are always required.
        && request.resource.data.keys().size() >= 7 && request.resource.data.keys().size() <= 10;


      allow update: if request.auth.uid != null && request.auth.uid == resource.data.requestedBy &&
                       // Allow status changes, linking to an active ryd, and updating notes or passengerIds by requester
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'assignedActiveRydId', 'notes', 'passengerIds', 'updatedAt']);
      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.requestedBy && resource.data.status == "requested";
    }

    // Rules for active rydz
    match /activeRydz/{activeRydId} {
      allow create: if
                       // Core permission check: The user (driverId in the doc) must have 'canDrive' set to true.
                       get(/databases/$(database)/documents/users/$(request.resource.data.driverId)).data.canDrive == true &&
                       // Validate required fields and their types for the incoming document data
                       request.resource.data.driverId is string && request.resource.data.driverId.size() > 0 &&
                       request.resource.data.associatedEventId is string && request.resource.data.associatedEventId.size() > 0 &&
                       request.resource.data.status is string && request.resource.data.status == "planning" && // Initial status must be "planning"
                       request.resource.data.vehicleDetails is map &&
                       request.resource.data.vehicleDetails.make is string && // make can be "N/A"
                       request.resource.data.vehicleDetails.model is string && // model can be "N/A"
                       request.resource.data.vehicleDetails.passengerCapacity is string &&
                       request.resource.data.vehicleDetails.passengerCapacity.matches("^[1-8]$") && // Capacity 1-8
                       request.resource.data.passengerManifest is list && request.resource.data.passengerManifest.size() == 0 && // Must be empty on create
                       request.resource.data.actualDepartureTime is timestamp &&
                       // startLocationAddress must be a non-empty string (can be "Driver's general area")
                       request.resource.data.startLocationAddress is string && request.resource.data.startLocationAddress.size() > 0 &&
                       // finalDestinationAddress must be a non-empty string (comes from eventData.location)
                       request.resource.data.finalDestinationAddress is string && request.resource.data.finalDestinationAddress.size() > 0 &&
                       // notes can be an empty string
                       request.resource.data.notes is string &&
                       // Key checks (ensure createdAt, updatedAt are NOT checked here as they are set by serverTimestamp by the action)
                       request.resource.data.keys().hasAll(['driverId', 'associatedEventId', 'status', 'vehicleDetails', 'passengerManifest', 'actualDepartureTime', 'startLocationAddress', 'finalDestinationAddress', 'notes']) &&
                       request.resource.data.keys().size() == 9; // Exact number of fields sent by client in the action

      // Read rule: Any authenticated user can read activeRydz list for an event.
      allow read: if request.auth.uid != null;

      allow update: if request.auth.uid == resource.data.driverId &&
                       // Prevent changing immutable fields by the driver
                       request.resource.data.driverId == resource.data.driverId &&
                       request.resource.data.associatedEventId == resource.data.associatedEventId &&
                       // Allow specific fields to be updated by the driver
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                         'status', 'vehicleDetails', 'notes', 'actualDepartureTime', 'estimatedCompletionTime',
                         'startLocationAddress', 'finalDestinationAddress', 'routePolyline', 'passengerManifest', 'updatedAt'
                       ]) &&
                       // Basic validation for passengerManifest items if it's being updated
                       (request.resource.data.passengerManifest.size() == 0 ||
                         request.resource.data.passengerManifest.all(item,
                           item.userId is string && item.userId.size() > 0 &&
                           item.originalRydRequestId is string && item.originalRydRequestId.size() > 0 &&
                           item.pickupAddress is string && item.pickupAddress.size() > 0 &&
                           item.destinationAddress is string && item.destinationAddress.size() > 0 &&
                           item.status is string && (
                             item.status == "awaiting_pickup" || item.status == "on_board" ||
                             item.status == "dropped_off" || item.status == "missed_pickup" ||
                             item.status == "cancelled_by_passenger"
                           )
                           // Optional fields in manifest don't need explicit type checks here if they can be absent
                         ));
      allow delete: if false; // Generally, don't allow client deletion; archive or mark as cancelled instead.
    }
  }
}
