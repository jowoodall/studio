
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Rules for user profiles
    match /users/{userId} {
      // Allow users to read their own profile and other basic profiles if authenticated
      allow read: if request.auth.uid != null;
      // Allow users to create their own profile (e.g., on signup)
      allow create: if request.auth.uid != null && request.auth.uid == userId;
      // Allow users to update their own profile
      allow update: if request.auth.uid != null && request.auth.uid == userId;
      // Generally, disallow direct deletion of user profiles from client
      allow delete: if false;
    }

    // Rules for groups
    match /groups/{groupId} {
      allow read: if request.auth.uid != null; // Any authenticated user can read group details
      allow create: if request.auth.uid != null 
                    && request.auth.uid == request.resource.data.createdBy
                    && request.resource.data.name is string && request.resource.data.name.size() > 0
                    && request.resource.data.description is string
                    && request.resource.data.memberIds is list && request.resource.data.memberIds.size() > 0 && request.auth.uid in request.resource.data.memberIds
                    && request.resource.data.adminIds is list && request.resource.data.adminIds.size() > 0 && request.auth.uid in request.resource.data.adminIds;
      allow update: if request.auth.uid != null && request.auth.uid in resource.data.adminIds; // Only group admins can update
      allow delete: if request.auth.uid != null && request.auth.uid in resource.data.adminIds; // Only group admins can delete
    }

    // Rules for events
    match /events/{eventId} {
      allow read: if request.auth.uid != null; // Any authenticated user can read event details
      allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.createdBy;
      allow update: if request.auth.uid != null && request.auth.uid == resource.data.createdBy; // Only event creator can update
      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.createdBy; // Only event creator can delete
    }

    // Rules for event driver states
    match /eventDriverStates/{stateId} {
        allow read: if request.auth.uid != null;
        allow create: if request.auth.uid != null && request.auth.uid == request.resource.data.driverId;
        allow update: if request.auth.uid != null && request.auth.uid == resource.data.driverId;
        allow delete: if false; // Or based on specific conditions like event creator
    }

    // Rules for rydz (individual ride requests)
    match /rydz/{rydId} {
      allow read: if request.auth.uid != null; // Define more specific read rules later (e.g., involved users)
      
      allow create: if request.auth.uid != null
        && request.auth.uid == request.resource.data.requestedBy
        && request.resource.data.destination is string && request.resource.data.destination.size() > 0
        && request.resource.data.pickupLocation is string && request.resource.data.pickupLocation.size() > 0
        && request.resource.data.rydTimestamp is timestamp
        && request.resource.data.earliestPickupTimestamp is timestamp
        && request.resource.data.status is string && request.resource.data.status == "requested"
        && request.resource.data.passengerIds is list && request.resource.data.passengerIds.size() > 0
        && (request.resource.data.notes == null || request.resource.data.notes is string)
        && request.resource.data.createdAt == request.time 
        && (request.resource.data.eventId == null || request.resource.data.eventId is string)
        && (request.resource.data.eventName == null || request.resource.data.eventName is string)
        && request.resource.data.keys().hasAll(['requestedBy', 'destination', 'pickupLocation', 'rydTimestamp', 'earliestPickupTimestamp', 'status', 'passengerIds', 'createdAt'])
        && request.resource.data.keys().size() >= 8 && request.resource.data.keys().size() <= 11;

      // Allow requester to update their own request (e.g. status, notes, assignedActiveRydId)
      allow update: if request.auth.uid != null
                      && request.auth.uid == resource.data.requestedBy
                      // Check that only allowed fields are being modified or all fields are present as expected if a full update
                      && (
                           // Case 1: Only specific fields are being updated (status, notes, assignedActiveRydId)
                           (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'notes', 'assignedActiveRydId', 'updatedAt']))
                           ||
                           // Case 2: A more complete update, ensure critical fields are not changed by requester if they are re-sent
                           (
                             request.resource.data.requestedBy == resource.data.requestedBy &&
                             request.resource.data.destination == resource.data.destination &&
                             request.resource.data.pickupLocation == resource.data.pickupLocation &&
                             request.resource.data.rydTimestamp == resource.data.rydTimestamp &&
                             request.resource.data.passengerIds == resource.data.passengerIds &&
                             request.resource.data.createdAt == resource.data.createdAt
                           )
                         )
                      && request.resource.data.updatedAt == request.time;
                      
      allow delete: if request.auth.uid != null && request.auth.uid == resource.data.requestedBy && resource.data.status == "requested"; // Only requester can delete if still in 'requested' state
    }

    // Rules for Active Rydz (actual trips offered/managed by drivers)
    match /activeRydz/{activeRydId} {
      // Driver creating the ActiveRyd must be authenticated and marked as canDrive in their profile
      allow create: if request.auth.uid != null
                    && request.auth.uid == request.resource.data.driverId  // driverId in doc must match authenticated user
                    && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.canDrive == true // User must be a driver
                    // Validate essential fields and structure from createActiveRydForEventAction
                    && request.resource.data.driverId is string
                    && request.resource.data.associatedEventId is string // Event ID is required for this creation flow
                    && request.resource.data.status is string // e.g., 'planning' or 'awaiting_passengers'
                    && request.resource.data.vehicleDetails is map
                    && request.resource.data.vehicleDetails.keys().hasAll(['make', 'model', 'passengerCapacity'])
                    && request.resource.data.passengerManifest is list
                    && request.resource.data.passengerManifest.size() == 0 // Manifest should be empty on initial offer
                    && request.resource.data.actualDepartureTime is timestamp // Proposed departure by driver
                    && request.resource.data.startLocationAddress is string
                    && request.resource.data.finalDestinationAddress is string
                    && (request.resource.data.notes == null || request.resource.data.notes is string)
                    && request.resource.data.createdAt == request.time // Timestamps
                    && request.resource.data.updatedAt == request.time
                    // Check for exact field count to prevent extra fields
                    && request.resource.data.keys().size() == 11; // Count of fields in ActiveRyd excluding 'id'

      // Driver of the ryd OR a passenger listed in the manifest can read it
      allow read: if request.auth.uid != null
                  && (resource.data.driverId == request.auth.uid
                      || request.auth.uid in resource.data.passengerManifest.map(p => p.userId));

      // Only the driver of this ActiveRyd can update it
      allow update: if request.auth.uid != null
                    && resource.data.driverId == request.auth.uid // Must be the driver
                    // Prevent changing immutable fields after creation
                    && request.resource.data.driverId == resource.data.driverId
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.associatedEventId == resource.data.associatedEventId
                    // Validate passengerManifest structure if updated
                    && request.resource.data.passengerManifest is list
                    // Basic validation for items in passengerManifest: ensure each has userId, status, addresses, originalRydRequestId
                    && request.resource.data.passengerManifest.all(item =>
                        item.keys().hasAll(['userId', 'status', 'pickupAddress', 'destinationAddress', 'originalRydRequestId'])
                        && item.userId is string
                        && item.status is string // Further validation of status enum values can be added
                        && item.pickupAddress is string
                        && item.destinationAddress is string
                        && item.originalRydRequestId is string
                        && (item.notes == null || item.notes is string)
                        // Ensure no unexpected fields in manifest items and check size
                        && item.keys().size() >= 5 && item.keys().size() <= 11 // Based on PassengerManifestItem fields
                    )
                    && request.resource.data.updatedAt == request.time; // Ensure updatedAt is server timestamp

      // Deletion is disallowed for now; ActiveRydz should be marked as 'completed' or 'cancelled'
      allow delete: if false;
    }

  }
}
